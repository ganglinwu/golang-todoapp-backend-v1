package server

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/ganglinwu/todoapp-backend-v1/errs"
	"github.com/ganglinwu/todoapp-backend-v1/models"
	"go.mongodb.org/mongo-driver/v2/bson"
)

// TODO: CreateProj returns string while CreateTodo returns interface{}/int
// probably better to standardise what we want to return for both Create methods
type TodoStore interface {
	GetAllProjs() ([]models.PROJECT, error)
	GetAllTodos() ([]models.TODO, error)
	GetProjByID(ID string) (models.PROJECT, error)
	CreateProj(Name string, Tasks []models.TODO) (string, error)
	CreateTodo(projID string, newTodoWithoutID models.TODO) (string, error)
	UpdateProjNameByID(ID, newName string) error
	UpdateTodoByID(todoID string, newTodoWithoutID models.TODO) error
	DeleteProjByID(ID string) (int, error)
	DeleteTodoByID(todoID string) (int, error)
	GetTodoByID(todoID string) (models.TODO, error)
}

type TodoServer struct {
	TodoStore TodoStore
	http.Handler
}

const whitelist = "http://localhost:5173"

func enableCors(w *http.ResponseWriter) {
	(*w).Header().Set("Access-Control-Allow-Origin", whitelist)
	(*w).Header().Set("Access-Control-Allow-Methods", "GET, POST, PATCH, DELETE, OPTIONS")
	(*w).Header().Set("Access-Control-Allow-Headers", "Access-Control-Allow-Headers, Content-Type, Authorization, X-Requested-With")
}

// function to handle pre flight request
func handlePreFlight(w http.ResponseWriter, r *http.Request) {
	// we already know http.Request.Method == "OPTIONS"
	if r.Header.Get("Access-Control-Request-Method") != "" {
		w.Header().Set("Access-Control-Allow-Origin", r.Header.Get("Origin"))
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PATCH, DELETE, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Access-Control-Allow-Headers, Content-Type, Authorization, X-Requested-With")
		return
	}
}

func NewTodoServer(store TodoStore) *TodoServer {
	r := http.NewServeMux()
	ts := &TodoServer{}
	ts.Handler = r
	ts.TodoStore = store

	r.HandleFunc("GET /proj", ts.handleGetAllProjs)
	r.HandleFunc("GET /todo", ts.handleGetAllTodos)
	r.HandleFunc("GET /proj/{ID}", ts.handleGetProjByID)
	r.HandleFunc("OPTIONS /proj/", handlePreFlight)
	r.HandleFunc("POST /proj/", ts.handleCreateProj)
	r.HandleFunc("OPTIONS /proj/{ID}", handlePreFlight)
	r.HandleFunc("OPTIONS /todo/{ID}", handlePreFlight)
	r.HandleFunc("POST /proj/{ID}", ts.handleCreateTodo)
	r.HandleFunc("PATCH /proj/{ID}", ts.handleUpdateProjNameByID)
	r.HandleFunc("PATCH /todo/{ID}", ts.handleUpdateTodoByID)
	r.HandleFunc("DELETE /proj/{ID}", ts.handleDeleteProjByID)
	r.HandleFunc("DELETE /todo/{ID}", ts.handleDeleteTodoByID)
	return ts
}

// handleGetAllProjs
//
// endpoint: "GET /proj"
func (ts TodoServer) handleGetAllProjs(w http.ResponseWriter, r *http.Request) {
	enableCors(&w)
	projs, err := ts.TodoStore.GetAllProjs()

	switch err {
	case errs.ErrNotFound:
		w.WriteHeader(http.StatusNotFound)
	case nil:
		w.Header().Set("Content-Type", "application/json")
		err := json.NewEncoder(w).Encode(projs)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintf(w, "%s", err.Error())
			return
		}

	default:
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "err: %s", err.Error())
	}
}

// handleGetAllTodos
//
// endpoint: "GET /todo"
func (ts TodoServer) handleGetAllTodos(w http.ResponseWriter, r *http.Request) {
	enableCors(&w)
	todos, err := ts.TodoStore.GetAllTodos()

	switch err {
	case errs.ErrNotFound:
		w.WriteHeader(http.StatusNotFound)
	case nil:
		w.Header().Set("Content-Type", "application/json")
		err := json.NewEncoder(w).Encode(todos)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintf(w, "%s", err.Error())
			return
		}

		w.WriteHeader(http.StatusOK)
	default:
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "err: %s", err.Error())
	}
}

// handleGetProjByID
//
// endpoint: "GET /proj/{ID}"
func (ts TodoServer) handleGetProjByID(w http.ResponseWriter, r *http.Request) {
	enableCors(&w)
	ID := r.PathValue("ID")
	proj, err := ts.TodoStore.GetProjByID(ID)

	switch err {
	case errs.ErrNotFound:
		w.WriteHeader(http.StatusNotFound)
	case nil:
		w.Header().Set("Content-Type", "application/json")
		err := json.NewEncoder(w).Encode(proj)
		if err != nil {
			log.Println("handleGetProjByID failed to encode into json:", err.Error())
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintf(w, "%s", err.Error())
			return
		}
	default:
		log.Println("handleGetProjByID failed with error", err.Error())
		w.WriteHeader(http.StatusInternalServerError)
	}
}

// handleCreateProj
//
// endpoint: "POST /proj"
//
// link to project struct in docs: (under construction)
//
// - CreateProj requires ONLY the project name from the frontend
// - The ID will be auto-generated by mongodb/postgres
// - Project will be created with empty array/slice of TODOs
func (ts TodoServer) handleCreateProj(w http.ResponseWriter, r *http.Request) {
	enableCors(&w)

	project := models.PROJECT{}
	decoder := json.NewDecoder(r.Body)
	err := decoder.Decode(&project)
	if err != nil {
		log.Println("failed to unmarshal json to TODO struct: ", err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "%s", err.Error())
		return
	}

	tasks := []models.TODO{}

	insertedID, err := ts.TodoStore.CreateProj(project.ProjName, tasks)
	if err != nil {
		log.Println("failed to create proj on data store: ", err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "%s", err.Error())
		return
	}
	log.Printf("Sucessfully created proj \n ID: %s \n ProjName: %s \n Tasks: %#v \n", insertedID, project.ProjName, tasks)
	w.WriteHeader(http.StatusCreated)
	fmt.Fprintf(w, "%s \n Sucessfully created proj \n ID: %s \n ProjName: %s \n Tasks: %#v \n", insertedID, insertedID, project.ProjName, tasks)
}

// handleCreateTodo
//
// endpoint: "POST /proj/{ID}"
func (ts TodoServer) handleCreateTodo(w http.ResponseWriter, r *http.Request) {
	enableCors(&w)
	todo := models.TODO{}
	decoder := json.NewDecoder(r.Body)
	err := decoder.Decode(&todo)
	if err != nil {
		log.Println("failed to unmarshal json to TODO struct: ", err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "%s", err.Error())
		return
	}

	newTodoWithoutID := models.TODO{}

	projID := r.PathValue("ID")
	if todo.DueDateString != "" {
		dueDate, err := time.Parse(time.RFC3339, todo.DueDateString)
		if err != nil {
			log.Println("failed to parse date string to date: ", err.Error())
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintf(w, "%s", err.Error())
			return
		}
		newTodoWithoutID.DueDate = &dueDate
	}

	newTodoWithoutID = models.TODO{
		Name:        todo.Name,
		Description: todo.Description,
		Priority:    todo.Priority,
		Completed:   todo.Completed,
		Updated_at:  &bson.Timestamp{T: uint32(time.Now().Unix())},
	}
	upsertedID, err := ts.TodoStore.CreateTodo(projID, newTodoWithoutID)
	if err != nil {
		log.Println("failed to create todo on data store: ", err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "%s", err.Error())
		return
	}

	w.WriteHeader(http.StatusCreated)
	fmt.Fprintf(w, "%s\n Successfully created todo \n ID: %s \n Name: %s \n Description: %s \n DueDate: %s \n Priority: %s \n Completed: %t \n", upsertedID, upsertedID, todo.Name, todo.Description, todo.DueDate, todo.Priority, todo.Completed)
}

// handleUpdateProjNameByID
//
// endpoint: "PATCH /proj/{ID}"
func (ts TodoServer) handleUpdateProjNameByID(w http.ResponseWriter, r *http.Request) {
	enableCors(&w)
	updatedProj := models.PROJECT{}

	decoder := json.NewDecoder(r.Body)
	err := decoder.Decode(&updatedProj)
	if err != nil {
		log.Println("failed to unmarshal json to PROJECT struct: ", err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "%s", err.Error())
		return
	}

	ID := r.PathValue("ID")
	newProjName := updatedProj.ProjName

	err = ts.TodoStore.UpdateProjNameByID(ID, newProjName)
	if err != nil {
		log.Println("failed to update proj name on data store: ", err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "%s", err.Error())
		return
	}
	log.Printf("Sucessfully updated proj name \n ID: %s \n ProjName: %s \n", ID, newProjName)
	w.WriteHeader(http.StatusOK)
	fmt.Fprintf(w, "\n Sucessfully updated proj name \n ID: %s \n ProjName: %s \n", ID, newProjName)
}

// handleUpdateTodoByID
//
// endpoint: "PATCH /todo/{ID}"
//
// - handleUpdateTodoByID will take in the updatedTodo through json
// - then it will search data store for existing todo under the ID
// - compares the fields
// - if the updatedTodo has blank fields, the existing field will be used
// - else it supercedes existing field
func (ts TodoServer) handleUpdateTodoByID(w http.ResponseWriter, r *http.Request) {
	enableCors(&w)

	updatedTodo := models.TODO{}

	decoder := json.NewDecoder(r.Body)
	err := decoder.Decode(&updatedTodo)
	if err != nil {
		log.Println("failed to unmarshal json to TODO struct: ", err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "%s", err.Error())
		return
	}

	todoID := r.PathValue("ID")

	currentTodo, err := ts.TodoStore.GetTodoByID(todoID)
	if err != nil {
		log.Println("failed to GetTodoByID: ", err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "%s", err.Error())
		return
	}

	// check and update

	// Name should never be empty
	todoName := ""
	if updatedTodo.Name == "" {
		todoName = currentTodo.Name
	} else {
		todoName = updatedTodo.Name
	}

	todoDescription := ""
	if updatedTodo.Description == "" {
		todoDescription = currentTodo.Description
	} else {
		todoDescription = updatedTodo.Description
	}

	todoDueDate := currentTodo.DueDate
	if updatedTodo.DueDateString != "" {
		newDueDate, err := time.Parse(time.RFC3339, updatedTodo.DueDateString)
		if err != nil {
			log.Println("failed to parse date string: ", err.Error())
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintf(w, "%s", err.Error())
			return
		}
		todoDueDate = &newDueDate
	}

	todoPriority := ""
	if updatedTodo.Priority == "" {
		todoPriority = currentTodo.Priority
	} else {
		todoPriority = updatedTodo.Priority
	}

	todoCompleted := updatedTodo.Completed

	updatedTodoWithoutID := models.TODO{
		Name:        todoName,
		Description: todoDescription,
		DueDate:     todoDueDate,
		Priority:    todoPriority,
		Completed:   todoCompleted,
		Updated_at:  &bson.Timestamp{T: uint32(time.Now().Unix())},
	}

	err = ts.TodoStore.UpdateTodoByID(todoID, updatedTodoWithoutID)
	if err != nil {
		log.Println("failed to update todo by id: ", err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "%s", err.Error())
		return
	}
	w.WriteHeader(http.StatusOK)
	log.Printf("Sucessfully updated todo \n ID: %s \n Name: %s \n Description: %s \n DueDate: %s \n Priority: %s \n Completed: %t \n", todoID, updatedTodoWithoutID.Name, updatedTodoWithoutID.Description, r.FormValue("DueDate"), updatedTodoWithoutID.Priority, updatedTodoWithoutID.Completed)
	fmt.Fprintf(w, "\n Sucessfully updated todo \n ID: %s \n Name: %s \n Description: %s \n DueDate: %s \n Priority: %s \n Completed %t \n", todoID, updatedTodoWithoutID.Name, updatedTodoWithoutID.Description, r.FormValue("DueDate"), updatedTodoWithoutID.Priority, updatedTodoWithoutID.Completed)
}

// handleDeleteProjByID
//
// endpoint: "DELETE /proj/{ID}"
func (ts TodoServer) handleDeleteProjByID(w http.ResponseWriter, r *http.Request) {
	enableCors(&w)
	ID := r.PathValue("ID")

	deletedCount, err := ts.TodoStore.DeleteProjByID(ID)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "%s", err.Error())
		return
	}
	w.WriteHeader(http.StatusOK)
	fmt.Fprintf(w, "Number of projects deleted: %d", deletedCount)
}

// handleDeleteTodoByID
//
// endpoint: "DELETE /todo/{ID}"
func (ts TodoServer) handleDeleteTodoByID(w http.ResponseWriter, r *http.Request) {
	enableCors(&w)
	todoID := r.PathValue("ID")

	deletedCount, err := ts.TodoStore.DeleteTodoByID(todoID)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "%s", err.Error())
		return
	}
	if deletedCount != 1 {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprint(w, "we could not delete the todo. something went wrong on our end.")
		return
	}
	w.WriteHeader(http.StatusOK)
	fmt.Fprintf(w, "Number of todos deleted: %d", deletedCount)
}
